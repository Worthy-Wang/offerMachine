@[toc]

<br>

## 简述 const 关键字？
>**const的作用是告诉编译器某个值是不变的，可以理解成只读，对变量起到保护作用。**

**const可以用于以下方面：**
1. **修饰普通变量**
需要在一开始就进行初始化；

2. **修饰指针**
根据在 * 前后可以分为常量指针和指针常量，当然也可以前后都修饰，如`const int* a` ， `int* const  a`，`const int * const a`。

3. **修饰函数中的参数与返回值**
* 修饰函数中的参数：const在函数的参数中可以保护指针不被修改，如`strcpy(char* des, const char* src)`；
* 修饰函数的返回值：也可以保证返回值指针的内容不被修改，如 `const char* getStr()` 中，接收类型就必须是 `const char *`。

4. **修饰类中的成员变量与成员函数**
* 修饰成员函数时，不能对其成员变量进行修改（本质是修饰this指针）；且const修饰的成员函数可以被const，非const对象调用，但是普通成员函数只能被普通对象调用。
* 修饰成员变量时，必须在构造函数列表里进行初始化。 


 **延伸用法：const + &**
 
如`const string& s`，在满足的`引用传递的优点`下，既可以保护`别名不被修改`，也可以
`接收右值`（接收右值的原因在于右值都是const属性且不可见，只有const传递能捕捉到）。

<br>


------------------------------------------

## 简述 static 关键字？
>**static 修饰的数据存放在全局数据区，限定了作用域，并且生命周期是直到程序结束。**

**C中的用法：**
1. **静态局部变量**
一般用在函数中，当函数第一次被调用时会在`全局数据区初始化`，其作用域只存在于该`函数`中。
2. **静态全局变量**
静态全局变量不能为其他文件所用，`作用域只在该文件中`。
3. **静态函数**
与静态全局变量的作用类似，静态函数不能为其他文件所用，`作用域只在该文件中`。

**C++中的用法（包含C中的用法）：**
1. **static修饰类成员变量**
静态成员变量`属于整个类`，在`类实例之间共享`，也就是说无论创建多少个类的对象，该成员变量都只有一个副本。
同时由于静态成员变量属于整个类，所以`只能在类内申明，在类外初始化`。如果在类内就初始化，那么会导致每一个实例化的对象都拥有一个该成员变量，这是矛盾的。

2. **static修饰类成员函数**
静态成员函数属于整个类，`由于没有this指针，所以只能调用静态成员变量`；

<br>

----------------
## new/delete 和 malloc/free 的区别？
1. **最重要的一点**
`new/delete`可以调用类的构造函数，析构函数等；而`malloc/free`只是简单的申请和释放内存。
2. **本质类型**
new属于运算符，可重载；而malloc属于库函数，不可重载。
3. **参数**
new不需要参数就能够自动分配空间大小，malloc则需要传入申请内存块的大小。
4. **返回值**
new的返回值是相应类型的指针，malloc返回值是`void*`类型。
5. **申请内存失败**
new申请失败会抛出`bad_alloc` 异常，而malloc申请失败则会返回`NULL`。
6. **申请区域**
new操作从 自由存储区 申请内存， malloc 从堆区申请内存；自由存储区可以是堆区，也可以是全局静态数据区，这由`operator new(size_t)` 决定。
7. **处理数组**
new[]和delete[]必须配套使用来处理数组。

**延伸1: 既然new/delete的功能已经完全覆盖了malloc/free，为什么还要保留malloc/free呢？**
>**因为C++程序中经常会使用C，而C只能使用malloc/free进行动态内存申请和释放。**

<br>

**延伸2：写出重载new delete 的程序**
* 使用new运算符时，先调用 `operator new(size_t)`申请空间，再调用构造函数，然后返回指针；
* 使用delete运算符时，先调用析构函数，再调用 `operator delete(void*)`释放空间。


```cpp
class A
{
public:
    A() { cout << "A()" << endl; }
    ~A() { cout << "~A()" << endl; }

    void*  operator new(size_t n)
    {
        cout << "operator new(size_t)" << endl;
        void *ret = malloc(n);
        return ret;
    }

    void* operator new[](size_t n)
    {
        cout << "operator new[](size_t)" << endl;
        void *ret = malloc(n);
        return ret;    
    }

    void operator delete(void* p)
    {
        if (p)
        {
            cout << "operator delete(void*)" << endl;
            free(p);
            p = nullptr;
        }
    }

    void operator delete[](void* p)
    {
        if (p)
        {
            cout << "operator delete[](void*)" << endl;
            free(p);
            p = nullptr;
        }
    }
};
```
<br>

------------
## 简述extern关键字？
**extern关键字有两个作用：**
1. **跟”C”连用时**
`告诉编译器用C的规则进行编译`。因为如果使用C++的规则，由于C++支持函数的重载，所以会将函数名进行修改，导致程序报错。
2. **不与”C”进行连用时**
对于变量或函数只进行申明而不是定义，`提示编译器该变量或函数的定义需要在另一个文件中寻找`。在编译阶段，目标模块A虽然找不到extern 修饰的变量或者函数，但不会报错，而是在链接时从模块B中找到该函数或变量。

<br>

-------------------

## volatile关键字？

**volatile关键字的作用是让CPU取内存单元中的数据而不是寄存器中的数据。** 如果没有volatile，那么经过编译器优化，CPU会首先访问寄存器中的数据而不是内存单元中的数据（因为访问寄存器会更加快速），这样在多线程环境可能会读取脏数据。

**延伸1：一个参数可以既是const 又是 volatile吗？**

可以，const修饰代表变量只读，volatile修饰代表变量每次都需要从内存中读取。

**延伸2：volatile 可以修饰指针吗？**

可以，代表指针指向的地址是volatile的。

<br>

------------
## mutable关键字？

>**mutable是const的反义词，用来突破const的限制。const修饰的成员函数可以修改mutable修饰的成员变量。**


**程序实例：**

```cpp
class A
{
    mutable int _val = 10;
public:
    void display()const
    {
        _val = 20;
        cout << _val << endl;
    }
};
```

<br>

-----------------
## 指针与引用的区别？（C++中引用的特点？）
1. 引用是变量的别名，本身不具有单独的内存空间，属于直接访问；指针是指向地址的变量，有单独的内存空间，属于间接访问。

2. 引用在创建时就必须初始化，且不能更改绑定；指针可以不初始化，可以更改指向。

**总的来说，引用既有指针的效率，同时也更加方便直观。**

<br>

---------------------
## C++内存的五大分区？（内存的分配方式有哪几种？）
1.	**栈区**
通常存放局部变量，形参，函数调用等，其操作方式类似于数据结构中的栈。
2.	**堆区**
通过new malloc 等申请的内存块，其操作方式类似于数据结构中的链表。
3. **全局变量与静态变量区**
分为BSS段和Data段，BSS段存储未初始化的变量，Data段存储已经初始化的变量。
4. **常量区**
存放只读常量。
5. **代码区**
存放代码以及函数。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201022164045623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dvcnRoeV9XYW5n,size_16,color_FFFFFF,t_70#pic_center)

<br>

____________________________
## 堆和栈的区别？
1. 时间：栈由编译器自动分配释放，操作方式类似于数据结构中的栈；堆由程序员手动分配释放，操作方式类似于数据结构中的链表。
2. 空间：栈的空间有限，通常为8M；堆可以拥有较大的空间；
3. 效率：栈的分配由编译器完成，堆的分配由程序员完成，所以栈的效率比堆高很多。
4. 堆会产生内存碎片，栈不会；
5. 栈的生长方向向下，朝着低字节方向生长；堆的生长方向向上，朝着高字节的方向生长。
6.  堆属于动态分配，没有静态分配的堆；栈由静态分配与动态分配两种方式，但是栈的动态分配由编译器控制。

<br>

--------------------
## 静态内存分配与动态内存分配的区别？
1. **时间**：静态内存分配在编译时期完成；动态内存分配在程序运行时期完成。
2. **空间**：堆属于动态分配，没有静态分配的堆；栈由静态分配与动态分配两种方式，但是栈的动态分配由编译器控制完成，因为栈只能由编译器分配释放。

<br>

------------------
## 深拷贝与浅拷贝
* **浅拷贝**
只是对指针的拷贝，拷贝后会有两个指针指向同一个内存空间；

* **深拷贝**
对指针指向的内容进行拷贝，拷贝后会有两个指针指向不同的内存空间；

**浅拷贝可能会出现问题，因为两个指针指向同一块内存区域，一个指针的修改会造成另一个指针错误，如出现两个对象析构，两次delete内存的情况。**

<br>

----------------
## 枚举(enum) 和 宏(#define) 的区别？
1. 宏是在预编译阶段进行简单的替换操作，并不占用内存；枚举在编译阶段进行替换，需要占用内存。
2. 宏一次性只能定义一个，枚举一次性可以定义多个。

<br>

-----------------------------

## define 和typedef 的区别？
宏只是在预编译阶段进行简单的替换操作，并不占用内存；typedef相当于起别名，在编译阶段进行，并不占用内存。

<br>


----------------
## using 和typedef 的区别？
using 和 typedef 类似，都是相当于起别名，不占用内存，在编译阶段进行。且using比typedef更加简洁。

<br>


----------------
## 内联函数（inline）是什么？与宏的区别是什么？
* **当函数被申明为内联函数之后，编译器编译时会将其内联展开，而不是按照普通的函数调用机制进行压栈调用**；这样大大减小了调用函数的时间开支，但也增加了程序的占用空间，相当于是`空间换时间`的策略。

* **宏只是在预编译阶段进行简单的宏替换**，极其容易出错；而内联展开则在编译阶段进行，不易出错。

另外注意：
1. 内联函数一般是不超过10行的小函数；
2. 内联函数中不允许使用循环和开关语句；
3. 类成员函数默认加上inline，但具体是否进行内联由编译器决定。
4. 滥用内联函数可能会占用大量内存空间，反而导致程序变慢。


<br>


------------
## struct 与 class 的区别？ 
**struct和class的区别主要在于 默认访问级别 和 默认继承级别。**

1. **默认访问级别**：struct中的成员默认是public，class中的成员默认是private。
2. **默认继承级别**：struct默认public继承，class默认private继承。

**除了这两点外，struct 和 class 完全相同。**

<br>

-----------
## struct 和 union 的区别？
**这两个的区别在于内存空间的分配。**

* **struct**
使用struct时，编译器会给每一个struct成员变量分配空间，并且每一个成员变量互不干扰；

* **union**
 使用union时，编译器会让union中的成员变量共享同一个空间，并且会根据定义顺序对之前的成员变量进行覆盖。当成员变量的相关性不强时，可以使用union节省内存空间。

**注意**：class，struct 和 union 都需要进行内存对齐。

<br>

-----------------
## 内存对齐是什么？（字节对齐）

现代计算机中的内存空间都是按照字节划分的，**CPU实际读取内存时，是按照k字节进行读取而不是一个字节一个字节读取，这就是内存对齐**；有了内存对齐之后，CPU可以一次性读取k字节的数据，变得更加高效。

**注意**：
1. k通常为最大成员数据类型的大小，结构体的大小也应该为k的整数倍。

2. 在union，class，struct中均有内存对齐；但是也可以通过 `#pragma push(k)`， `#pragma pop()` 来设置内存对齐的方式。

<br>

-------------------
## 右值引用是什么？移动语义是什么？move函数的作用？
**右值**： 左值是可以取到地址的值，右值是不能够取到地址的值。右值主要用于实现移动语义。

**移动语义**：以`移动而非深拷贝`的方式初始化`含有指针成员的类对象`。将对象（通常是右值）的`内存资源移动为自己使用`，这样减小了多次申请释放内存空间的开销。在类中，通常有专门的 `移动构造函数` 与 `移动赋值运算符` 来实现移动语义。

**move函数**：将左值强制转化为右值，转换后就能够调用 `移动构造函数` 与 `移动赋值运算符` 来减小多次申请释放内存空间的开销。


<br>

---------------------
## RVO返回值优化是什么？
返回值优化（Return value optimization，缩写为RVO）是C++的一项编译优化技术，即省略掉 `两次` 通过`拷贝构造函数` `创建临时对象` 的过程。这样大大节省了开销。

<br>

---------------------
## 简述智能指针？
**智能指针的本质也是指针，只是它可以帮助我们自动释放空间和避免野指针，避免了内存泄漏的风险。**

目前常用的智能指针有**三种**（**auto_ptr**已经淘汰）：
1. **unique_ptr**
一个对象只能由一个unique_ptr引用，当指针不再引用该对象时，该对象自动析构并释放内存。

2. **shared_ptr**
一个对象可以由多个shared_ptr引用，对象的被引数量可以用引用计数（`use_count`）来表示，当对象的引用计数为0时，将该对象自动析构并释放内存。

3. **weak_ptr**
weak_ptr是一种弱引用，不会增加对象的引用计数，是用来打破shared_ptr相互引用时的死锁问题。


**weak_ptr打破死锁的实例**：
```cpp
#include <iostream>
#include <memory>
using namespace std;
class B;
class A
{
public:
    A()
    {
        cout << "构造函数" << endl;
    }
    ~A()
    {
        cout << "析构函数" << endl;
    }
    weak_ptr<B> _pb;//若为shared_ptr，那么析构时只会析构pA和pB，但A 和 B 的引用计数仍为1，所以不能析构并释放内存
};

class B
{
public:
    B()
    {
        cout << "构造函数" << endl;
    }
    ~B()
    {
        cout << "析构函数" << endl;
    }
    weak_ptr<A> _pa;
};

int main()
{
    shared_ptr<A> pA(new A());
    shared_ptr<B> pB(new B());
    pA->_pb = pB;
    pB->_pa = pA;
    cout << "A的引用计数：" << pA.use_count() << endl;
    cout << "B的引用计数：" << pB.use_count() << endl;
    return 0;
}

```

<br>

--------------------
## C++有哪四种强制类型转换？
1. **static_cast**
static_cast也就是用于比较自然的类型之间的转换，相比C中的转换有安全检查机制。
2. **const_cast**
const_cast主要用于去除变量的const属性。
3. **reinterpret_cast**
reinterpret_cast可以用于不同类型数据之间的转换，是按照逐个比特进行复制。该转换具有很强的灵活性，但并不保证转换的安全性。
4. **dynamic_cast**
dynamic_cast主要用于将 多态基类的指针或引用 转换为 派生类的指针或引用，并且能够检查安全性。如果转换不安全，对指针则返回nullptr；对引用则抛出bad_cast异常。（`多态基类意味着必须由虚函数`）

<br>

-------------------
## 动态数组的实现？
创建 **m行n列** 的二维动态数组，通过以下两种方法：
1. **使用new**
   

```cpp
int **a = new int *[m];
   for (int i = 0; i < m; i++)
      a[i] = new int[n];
```

2. **使用vector**

```cpp
vector<vector<int>> nums(m, vector<int>(n, 0));
```

<br>

-------------------------
## 简述STL 库？
**STL库即标准模板库，是一个具有工业强度的高效C++库。**

1.	**容器**

分为**序列式容器**，**关联式容器**以及**容器适配器**。

2.	**算法**

是一种常用的算法模板，可以对容器，数组，自定义结构体进行操作。 

3.	**迭代器**

**是一种特殊的指针，作为容器库和算法库之间的粘合剂。可以将其看成一种泛型指针。** 从实现角度看，迭代器是通过重载*，->, ++, - - 等方式实现的。**可以将不同数据类型的访问逻辑抽象出来，在不暴露内部结构的情况下对元素进行遍历。**

4.	**适配器**

适配器分为 **函数适配器** 和 **容器适配器**；

* **函数适配器**
函数适配器通常通过bind，bind1st, bind2nd 实现，这三个函数都会返回一个新的函数。

* **容器适配器**
stack，queue，priority_queue既是序列式容器，也是容器适配器；stack，queue的标准模板是`deque`，priority_queue的标准模板是`vector`。

5.	 **配置器**

配置器的功能在于定义类中内存的分配，也就是 allocator一系列的函数，在各种容器中均存在，只是我们在使用时，allocator对我们来说是完全透明的。

6.	 **函数对象（仿函数 function object）**

可以理解为一种重载了 `() 运算符`的结构体，使用时可以当做函数来使用。


<br>

-----------------------
## 简述STL库中的容器以及特点？
1. **顺序容器**

* **vector**
底层由数组实现，支持快速随机访问，支持在尾部增删。适用于需要大量随机访问，且只需要在尾部增删的场景。

* **list**
底层由双向链表实现，不支持快速随机访问，支持快速增删。适用于不考虑随机访问，且需要大量插入和删除的场景。

* **deque**
底层由一个中央控制器和多个缓冲区实现，支持快速随机访问，支持在首尾进行快速增删。适用于需要大量随机访问，且需要在首尾进行快速增删的场景。

2. **关联容器**

* **map** 
底层由红黑树实现，元素有序且不可重复。以key-value 键值对方式存储，优点是元素有序，缺点是存储红黑树的节点需要消耗大量内存。

* **set**
底层由红黑树实现，元素有序且不可重复。优点是元素有序，缺点是存储红黑树的节点需要消耗大量内存。

* **unordered_map**
底层由hash表实现，元素无序且不可重复。以key-value键值对方式存储，优点是查询十分的高效。缺点是哈希表的建立需要消耗大量时间。

* **unordered_set**
底层由hash表实现，元素无序且不可重复。优点是查询十分的高效。缺点是哈希表的建立需要消耗大量时间。

**（若加上multi，则变为可重复）**


3.  **容器适配器**
* **stack**
底层由list或deque实现。适用于先进后出的场景。

* **queue**
底层由list或deque实现。适用于先进先出的场景。

* **priority_queue**
底层由vector实现，逻辑实现方式为heap（最大堆或最小堆）。适用于设置优先级队列的场景。

<br>

----------------------
## 简述vector的存储机制？
**vector内部实现是一个连续的动态数组**，当无法存储下所有元素时，进行三个步骤：
1. 申请一个更大的空间，通常是原空间大小的2倍；
2. 将原空间的数据拷贝到新的空间；
3. 释放掉原空间内存。

由此可见，vector的`动态扩容机制代价较高`。

<br>

--------------


## 简述list的存储机制？
list的底层实现是`双向链表`，按照节点进行存储的，节点在内存中的地址并不连续。
当元素插入时，则申请新的内存空间并插入节点；当元素删除时，则删除链表节点并释放该内存空间。

<br>


---------------------
## 简述deque的存储机制？
**deque底层是由一个中控器map和多个缓冲区组成**；
1. **中控器map**

这里的map不是STL中的map，而是一段连续存储空间，存储多个指向缓冲区的指针。

2. **缓冲区**

一段较大的连续存储空间，用于存储具体数据。

deque的迭代器也十分复杂，在deque内部有 start 和 finish 两个迭代器，每个迭代器组成如下：
* **cur**：指向缓冲区当前位置
* **first**：指向缓冲区头
* **last**：指向缓冲区尾
* **node**：指向中控器中当前位置

详情可见 《STL源码剖析》P146

<br>

----------------
## 什么情况下选择unorder_map 和 map？
选用map还是unordered_map，**关键在于看关键字的查询操作次数**。

如果查询操作次数较多，要求平均查询时间短，那么就使用`unordered_map`。

如果只有少次数的查询，unordered_map可能会造成不确定的O(N)，且创建也需要大量时间，那么就不如选用单词处理时间恒定为O(logN)的`map`。

<br>

------------
## 什么情况下选择set和map？
这两种数据类型的底层均为红黑树。

map更适合用于作为数据字典，也就是**关键字的查询**；

而set适用于**判断关键字是否在集合中**。

<br>

--------------
## 简述迭代器失效的情况？
迭代器失效分为三种情况。

1. **数组型数据结构**

由于该类型的元素都是存储在连续的内存空间中，进行插入和删除后会导致该 位置以及之后元素移位，也就导致该位置以及之后的迭代器失效。

2. 链表型数据结构

由于链表的特点，删除某一位置的元素只会让该位置的迭代器失效，不会影响其他迭代器。

3. 红黑树型数据结构

由于树本身也是一种链表，删除某一位置的元素只会让该位置的迭代器失效，不会影响其他迭代器。


<br>

------
## 没有迭代器的容器有哪些？
queue, stack, priority_queue。

<br>

--------------------
## 简述public ，protected，private 访问修饰符的区别?
1. **修饰成员时**

在**类的内部（定义该类的代码内部）**，无论成员被public，protected，private修饰，都可以随意访问。

在**类的外部（定义该类的代码外部）**，只有public修饰的成员能够被访问，protected和private修饰的成员均不能被访问。

class中如果不写则**默认是private修饰**。

2. **在继承时**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023115525110.png#pic_center)

 
class中如果不写则**默认是private继承**。



**注意**：不论哪一种方式，**基类的private成员均不能在派生类中使用**；但`并不是基类的private成员没有被派生类继承`，实质上是继承了并占用内存了的，只是不能使用。

<br>

-----------
## 派生类不能继承基类的哪些东西？
派生类可以继承基类的大部分资源，但是 **构造函数**，**析构函数**，**赋值运算符**，**友元** 不能够继承。

<br>

--------------------------
## 友元是什么？
友元可以分为**友元函数**以及**友元类**，**在类中申明，但是定义在类外部**，就可以访问类的所有protected和 private 成员。

**注意**：
1.	友元关系不能在类之间传递。
2.	友元声明只能出现在类定义中，并不属于该类的一部分（所以没有this指针），所以用public, protected, private 修饰均可。

<br>

-----------------
## this指针是什么？
**this 是所有类成员函数都有的一个隐式形参**。
实质上是 `成员函数` 连接 `成员变量` 的一座桥联，因为类中的成员函数都会被编译成与类无关的普通函数，而this指针指向了该对象的地址，所以可以用this指针来连接成员变量。

**注意**：
1.	友元函数没有this指针。
2.	(static)静态成员函数没有this指针。

<br>

-----------
## 简述C++中的多重继承？（菱形继承）
多继承会让程序变得复杂，同时可能会继承一些不必要的数据。
多继承容易出现命名冲突的问题，可以**加上域限定符（：：）**，或是**采用虚继承**来消除二义性。

<br>


------
## 什么情况下需要使用初始化列表初始化成员变量？
1. 类中有**const 修饰** 或者 **引用类型** 的成员变量；

2. 类中有必须用参数初始化的对象；

3. 派生类需要初始化基类的成员变量；

<br>

---------
## 类成员变量初始化的顺序？

是按照 **类中的声明顺序** 进行初始化的，并不是按照初始化列表的顺序进行初始化。

<br>

---------------
## 简述C++中的多态机制？（虚函数，多态相关问题）
**C++中的多态机制是通过虚函数来实现的。**

**多态**：是一个接口的多种形态。
实现多态的条件有两个：
1. **虚函数重写** 
2. **调用虚函数时必须使用指针或引用**。

**虚函数**：虚函数是带有 **virtual** 关键字的 **类成员函数**。实现多态需要进行 **虚函数重写**，也就是派生类有一个和基类完全相同（函数名，参数，返回值完全相同）的成员函数，也就称为虚函数重写（**覆盖**）。

**虚函数表**：有虚函数的类在编译时期都会生成一个 **虚函数表**，虚函数表实质上是一个 **指针数组**，存放 **指向虚函数的指针**；虚函数表是类对象之间**共享**的，在类中只存放一个**指向该 虚函数表的指针**。
在生成派生类过程中，**对虚函数表的操作有三个步骤**：
1. 将基类中的虚函数表指针拷贝到派生类中；
2. 派生类对基类虚函数进行覆盖（重写）；
3. 派生类将自己新增的虚函数依次添加在虚函数表后。

<br>

* **图示**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023151546950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dvcnRoeV9XYW5n,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023151553489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dvcnRoeV9XYW5n,size_16,color_FFFFFF,t_70#pic_center)

<br>

-----------
## 虚函数与纯虚函数的区别？
纯虚函数在基类中只申明不定义（如`virtual void func() = 0`），必须在派生类中进行覆盖重写虚函数表；拥有纯虚函数的基类被称为**虚基类（或抽象类）**，虚基类**不能实例化**，只能被继承。

<br>

----------
## C++中哪些函数不能是虚函数？
1. **构造函数不能是虚函数**

如果将构造函数设置为虚函数，那么派生类将无法创建，因为无法调用基类的构造函数。

2. **inline内联函数不能是虚函数**

因为内联函数会在编译时内联展开，而虚函数需要在运行时动态联编。

3. **友元函数不能是虚函数**

因为友元函数不属于类成员函数，虚函数必须是类成员函数。

4. **静态成员函数不能是虚函数**

因为静态成员函数不能够继承，虚函数无法进行覆盖。

<br>

------------
## 静态联编与动态联编？（静态绑定与动态绑定）
* 静态联编
是编译阶段就能确定的程序行为。

* 动态联编
是程序运行时进行的确定的程序行为，实质上是运行时虚函数的实现。

**编译时多态通过重载函数实现，运行时多态通过虚函数实现。**

<br>

----------
## 重载，隐藏，覆盖的区别？
* **重载**
在`同一个类`中，`函数名相同`，`参数类型(或个数) 不同`则为函数重载；如果只是 `返回值不同` 则不能称为重载。

* **隐藏**
若派生类的函数名与基类的 `函数名相同`，派生类的函数则会吧基类的函数隐藏起来。

* **覆盖**
派生类中的函数与基类中的虚函数完全相同（函数名，参数，返回值均相同），那么称为覆盖。


<br>

------------
## 构造函数与析构函数能否为虚函数？
* **构造函数不能为虚函数**
若构造函数为虚函数，那么派生类生成的过程中将会无法调用基类的构造函数。

* **析构函数可以为虚函数**
并且在实现多态情况下必须设置为析构函数，因为如果不将析构函数设置为虚函数，那么将无法调用派生类的析构函数从而造成内存泄漏。

<br>

------------
## 析构函数可以抛出异常吗？
**析构函数不能抛出异常**，原因如下：

1. 如果析构函数抛出异常，那么异常点之后的程序并不会执行，那么就会造成**内存泄漏**的问题。

2. 严格来说，**析构函数也是处理异常的一部分**；如果之前发生异常，调用析构函数来释放内存，若是析构函数也抛出异常，将会让程序崩溃。

<br>

------
## 空类中自带哪些函数？
六个函数:

* 构造函数
* 析构函数
* 拷贝构造函数
* 赋值运算符
* 取址运算符
* 取址运算符const。

**补充**：
取址运算符：T* operator&()
取址运算符const: const T* operator&() const

<br>


---------------
## 抽象类和接口的区别？
* 抽象类即是拥有纯虚函数的基类，不能够被实例化；
* 接口是一种特殊的抽象类，并且满足：1）类中没有任何成员变量；2）所有的成员函数都是公有且都是纯虚函数。
